# 議事録運用のための機能拡張フロー

## ドキュメントの目的
議事録用途での本アプリ運用に向けて、(1) UI改善、(2) 要約機能、(3) 話者識別を段階的に導入する際の技術的な流れと判断ポイントを整理する。各フェーズは小さな成果物を積み上げながら次段階に進める前提とし、さくらのレンタルサーバーを想定した構成を基準にする。

---

## UI改善フロー
### フェーズ0: 現状把握と要件整理
- 既存UIの画面遷移・操作ログを確認し、議事録作成のペルソナ（司会・書記など）と利用シナリオを洗い出す。
- 必須要件（録音状況の可視化、議題単位の区切り、メモ欄など）と Nice to have 要件を整理し、優先順位付けの指針を決める。

### フェーズ1: クイックリデザイン & 基盤整備
- `UIManager` / `DOMElements` の責務を棚卸しし、UI状態を明示したステート図を作成。進捗バーやボタン制御の役割を整理する。
- 画面上部に録音ステータス、下部に議題メモエリアなど、情報区画を再配置。既存CSSをリファクタ（コンポーネント単位のスタイル命名導入）。
- `TabManager` の履歴カードにメタ情報（日時、タグ、議題）を表示する枠を追加し、デザインモックをFigma等で作成してレビュー。

### フェーズ2: アクセシビリティ & フィードバック強化
- キーボード操作・スクリーンリーダー対応を強化。`aria-*` 属性やフォーカス管理を `UIManager` 経由で設定する。
- 録音開始/停止、要約完了、履歴保存など主要イベントに対し、トースト通知やバッジ表示を追加。イベントハンドラは `main.js` 内の `handle*` 系メソッドに集約。
- メイン画面・履歴画面のレスポンシブ対応を実施し、タブレット/スマホでの利用性を確認。

### フェーズ3: 議事録向け拡張
- セッション（会議）単位でのタブ・フィルタを導入し、複数会議の履歴を切り替えられるよう `TabManager` を拡張。
- 議題節のマーカー機能（手動で章区切りを登録し履歴と連動）を追加。UI上で章一覧・ジャンプ操作を提供。
- 変更箇所を `DebugUI` にも反映し、QA/運用チームがリアルタイムにUI状態を観測できるようにする。

---

## 要約機能フロー
### フェーズ0: 要約要件の明確化
- 要約の粒度（会議全体 / 議題別 / 発言ブロック別）と出力形式（箇条書き、要点+TODO など）をヒアリングし仕様化。
- セキュリティ要件（オンプレ限定、外部API可否）と処理遅延許容値を整理。要約対象テキストの最大長や保存ポリシーも決める。

### フェーズ1: サーバー連携の基盤づくり
- さくらレンタルサーバーに API 用のスクリプト（例: Python CGI / Node.js）を配置し、`/api/summarize` のようなエンドポイントを用意。
- ブラウザからは認識済みテキストとコンテキスト（議題、タイムスタンプ）を POST する流れを `main.js` に追加。通信層を分離（`SummaryService` など）してモジュール化。
- API 内で要約エンジンを抽象化。初期段階では簡易なテンプレート要約（発言数、キーワード抽出）でプロトタイプを成立させる。

### フェーズ2: 本格要約エンジンの統合
- 外部LLM（OpenAI、Gemini等）を利用する場合は、サーバー側でAPIキー管理・レート制御・失敗時リトライを実装。レスポンスエラーをUIに通知するフローを整える。
- オフラインや社内限定環境では、Whisper + Pegasus等の OSS モデルをサーバーに導入し、バッチ処理または非同期キューで実行。推論時間に応じてジョブ進捗のポーリング or SSE を導入。
- 要約結果を `TabManager` と連携し、履歴項目に「要約」タブを追加。JSON スキーマ（原文/要約/アクションアイテム等）を策定して保存。

### フェーズ3: 品質向上と運用整備
- 要約精度向上のために会議種別ごとのプロンプトテンプレートや要約ルールを管理。管理UI（要約テンプレート編集画面）を追加する。
- 要約結果へのフィードバック収集機能（ユーザーが修正した場合にログを蓄積）を実装し、継続的な改善につなげる。
- 長時間会議への対応として、タイムライン上で複数要約を生成し、全文要約と組み合わせて閲覧できるビューを設計。

---

## 話者識別フロー
### フェーズ0: 技術選定と前提条件の整理
- Web Speech API では話者識別が不可能なため、ブラウザ録音データをサーバーへ送る前提を確立。音声保存の許諾・セキュリティ要件を確認。
- 利用可能なエンジン（Google / Azure / AWS の diarization API もしくは OSS：Pyannote.audio 等）を調査し、さくらレンタルサーバー上での実行可否を評価。

### フェーズ1: 音声収集とアップロード基盤
- `MediaRecorder` API で音声をバッファリングし、一定間隔で WAV/WEBM をサーバーへ送信する実装を追加。既存 `SpeechRecognitionManager` と並行記録できるよう管理層を見直す。
- サーバー側で受信音声を一時保存し、処理キュー（cron or 非同期ジョブ）に渡す仕組みを整える。ファイル命名とメタデータ（発言時刻、会議ID）を標準化。

### フェーズ2: 話者分離 + 音声認識の導入
- クラウドAPI採用時：サーバー側で音声をアップロードし、話者タグ付きの文字起こし結果を取得。レスポンスを正規化し、話者ID・発言テキスト・タイムスタンプを JSON で返却。
- OSS採用時：Docker などの外部環境で diarization + speech-to-text パイプラインを実装し、さくらレンタルサーバーからは外部推論サーバーにリクエストする構成にする。もしくはレンタルサーバー上でのバッチ処理を検証。
- ブラウザ側では受信した話者情報を `TabManager` の履歴構造に取り込み、話者ごとの色分け・フィルタUIを設計。

### フェーズ3: リアルタイム性と改善
- 音声チャンクごとのリアルタイム返却が必要な場合、WebSocket や SSE による逐次更新を導入。クラウドAPIのストリーミング機能（例: Google Streaming STT）を利用する場合は専用ゲートウェイを実装。
- 話者プロフィール（名前・役職）との紐付けや、話者ごとの発言量サマリを UI に追加。議事録ダウンロード時にも話者情報を付与。
- プライバシー方針・ログ保管ポリシーを定義し、話者識別データの保存期間やマスキング方針を運用ルールに反映。

---

## クロスカットの考慮事項
- **セキュリティ/コンプライアンス**: 音声データ・テキスト要約・話者情報はいずれも機密性が高いため、HTTPS 必須、アクセス制御、ログマスキングを徹底する。
- **モニタリング**: `DebugLogger` / `VibeLogger` を活用し、サーバー側でもアクセスログ・エラーログを集約。フェーズ移行ごとに KPI (要約成功率、話者識別精度) を設定する。
- **ロールアウト戦略**: 各フェーズを社内検証→限定公開→全社展開のステップで進め、フィードバックと課題修正を組み込む。
